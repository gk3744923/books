To holistically analyze a mainframe application (e.g., COBOL + JCL + DB2 + VSAM + Copybooks + CICS) for modernization or migration, collecting all files in a folder is a great first step—but analysis requires a structured, multi-dimensional approach that covers code, data, dependencies, business rules, and runtime behavior.


---

🧭 GOAL: Holistic Migration Analysis Plan

> 🎯 Output: A migration strategy with detailed inventory, code metrics, system dependencies, business logic, and suitable modernization options.




---

✅ Step-by-Step Holistic Analysis Workflow

🗂️ Step 1: Organize the Codebase

/mainframe-app/
├── cobol/         → Business logic
├── copybooks/     → Data structure definitions
├── jcl/           → Job orchestration and batch logic
├── cics/          → UI and transaction logic
├── sql/           → DB2 interactions
├── vsam/          → File structures and IDCAMS scripts
├── config/        → Parameters, control cards
├── output/        → Reports, logs (optional)


---

📦 Step 2: Perform Inventory Analysis

Goal: Count and classify artifacts

Metric	Description

Programs	Count of .cbl files
Copybooks	Shared .cpy files
JCL Jobs	Batch processes (.jcl)
CICS Maps	.bms, screen definitions
DB2 Tables Accessed	SQL scripts or embedded SQL
VSAM Files Accessed	From SELECT and JCL DD
External Calls	CALL, PERFORM, EXEC CICS


💡 Use a script to traverse all folders and count these.


---

🧠 Step 3: Business Logic & Rule Extraction

Techniques:

Extract IF, EVALUATE, PERFORM blocks from COBOL

Use LLMs (Gemini, GPT-4) to summarize:

Decision logic

Eligibility rules

Tax/business conditions


Use natural language prompts:

> "Summarize the business logic in this COBOL paragraph and express it in plain English."




You can automate this using Gemini CLI on each COBOL paragraph.


---

🔗 Step 4: Dependency Mapping

Goal: Visualize how components connect

Program Call Tree: PERFORM and CALL hierarchy

File Access Map: VSAM/flat files and DB2 tables

Job Flow: Which JCLs run which programs, in what order

Copybook Reuse: Which copybooks are used where


💡 Store dependencies in a graph (e.g., JSON, Neo4j, or DOT format).


---

📉 Step 5: Complexity & Risk Scoring

Use heuristics to score:

Factor	Low	Medium	High

Cyclomatic Complexity	<10	10–20	>20
Code Volume	<500 LOC	500–3000	>3000 LOC
Copybook Nesting	0–1	2–3	>3
Embedded SQL	Few	Some	Many
CICS / BMS Screens	None	Some	Complex screens
External Dependencies	None	Internal only	External services
Business Criticality	Low	Medium	High


💡 Gemini or GPT can help:

> “Given this COBOL program, rate its complexity and explain why.”




---

🚦 Step 6: Modernization Readiness & Strategy Fit

Based on analysis, classify each program/module:

Criteria	Description	Strategy

Simple batch program	No SQL, no CICS, low complexity	Transpile or rewrite
DB2-heavy logic	Many SQL interactions	Rewrite w/ ORM
CICS online screen	UI-dependent COBOL with maps	Refactor or rehost
Copybook-heavy module	Many includes, reused across programs	Refactor
Deprecated	Not called, unused	Retire



---

🧾 Step 7: Generate Holistic Analysis Report

Create a structured report with:

📋 Executive Summary

of programs, copybooks, JCLs

Key findings

Recommended migration paths


📈 Code Metrics

Program LOC, complexity, # of SQLs, # of calls


🔍 Dependency Maps

Call graph

File access map

JCL → Program flow


📜 Business Rule Samples

Extracted English logic summaries


🧭 Strategy Matrix

Program	Strategy	Reason

PAYROLL1	Rewrite	High DB2 & logic complexity
EXTRACT1	Transpile	Simple batch extract job



---

🛠️ Tools You Can Use

Task	Tool

Code parsing	ANTLR (COBOL grammar), Python scripts
LLM integration	Gemini CLI / API
Dependency graph	Python + networkx or graphviz
Rule extraction	Gemini prompts
Report generation	Markdown → PDF (Pandoc)
Complexity scoring	Custom script or lizard (with COBOL support)



---

💡 Migration Strategy Options

Approach	Description	When to Use

Rehost	Move to cloud VM as-is (Lift & shift)	Short-term quick win
Refactor	Modularize, update architecture	Medium-term agility
Transpile	Convert COBOL → Java/C#/Python	Low-complexity programs
Rewrite	Rebuild logic in modern language	High-complexity or high-value logic
Retire	Remove unused programs	Unused/dead code



---

✅ Final Deliverables (from analysis)

1. Application Inventory (CSV / JSON)


2. Business Rules Summary (Markdown or Word)


3. Dependency Graphs (DOT, PNG, or web view)


4. Modernization Strategy Map


5. Executable Scorecard per program


6. Recommendations Report




---

🚀 Ready to Automate It?

I can generate:

A folder scanner + parser script

A Gemini integration example (Python or CLI)

A starter reporting tool


Would you like me to generate a Python project scaffold for this whole analysis?

